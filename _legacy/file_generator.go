package gen

import (
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/nategadzhi/protoc-gen-tfschema/util"
)

// fileGenerator represents generation methods for specific file
type fileGenerator struct {
	generator *Generator     // Reference to main generator
	file      *protogen.File // Current file
	*builder                 // Reference to output strings builder
}

func (f fileGenerator) generate() {
	f.printfHeader()
	f.printfMessages()
}

// Writes header with package name
func (f fileGenerator) printfHeader() {
	f.Printf("// DO NOT EDIT.")
	f.Printf("// Code is generated by protoc-gen-tfschema %s", Version)
	f.Printf("// Using protoc %s", f.generator.protocVersion)
	f.Printf("// Source: %s", f.file.Desc.Path())
	f.CrLf()
	f.Printf("package %s", f.generator.packageName)
	f.CrLf()
	f.Printf("import (")
	f.Printf(`    "github.com/hashicorp/terraform/helper/schema"`)
	f.Printf(`    "github.com/hashicorp/terraform/helper/validation"`)
	f.Printf(")")
	f.CrLf()
}

// Iterates over messages and starts generation of each specific message
func (f fileGenerator) printfMessages() {
	messages := f.file.Desc.Messages()

	for i := 0; i < messages.Len(); i++ {
		message := messages.Get(i)

		if f.isMessageExportable(message) {
			messageGenerator{
				message: message,
				builder: f.builder,
			}.generate()
		}
	}
}

// Checks if current message needs to be exported (name was passed in command line argument or argument is empty)
func (f fileGenerator) isMessageExportable(message protoreflect.MessageDescriptor) bool {
	if len(f.generator.types) == 0 {
		return true
	}

	return util.StrSliceContains(f.generator.types, string(message.Name()))
}
