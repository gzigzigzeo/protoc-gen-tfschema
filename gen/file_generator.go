package gen

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// fileGenerator represents generation methods for specific file
type fileGenerator struct {
	generator *Generator      // Reference to main generator
	file      *protogen.File  // Current file
	content   strings.Builder // Output content
}

func (f *fileGenerator) generate() {
	f.genHeader()
	f.genMessages()
}

// Writes formatted line to string builder
func (f *fileGenerator) println(format string, a ...interface{}) {
	fmt.Fprintf(&f.content, format, a...)
	f.printbn()
}

// Writes empty line
func (f *fileGenerator) printbn() {
	fmt.Fprintf(&f.content, "\n")
}

// Writes header with package name
func (f *fileGenerator) genHeader() {
	f.println("// DO NOT EDIT.")
	f.println("// Code is generated by protoc-gen-tfschema %s", Version)
	f.println("// Using protoc %s", f.generator.protocVersion)
	f.println("// Source: %s", f.file.Desc.Path())
	f.printbn()
	f.println("package %s", f.generator.packageName)
	f.printbn()
	f.println(`
	import (
		"github.com/hashicorp/terraform/helper/schema"
		"github.com/hashicorp/terraform/helper/validation"
	)
	`)
}

// Iterates over messages and starts generation of each specific message
func (f *fileGenerator) genMessages() {
	messages := f.file.Desc.Messages()

	for i := 0; i < messages.Len(); i++ {
		message := messages.Get(i)

		if f.isMessageExportable(message) {

		}
	}
}

// Checks if current message needs to be exported (name was passed in command line argument)
func (f *fileGenerator) isMessageExportable(message protoreflect.MessageDescriptor) bool {
	if len(f.generator.types) == 0 {
		return true
	}

	return contains(f.generator.types, string(message.Name()))
}

// contains returns true if slice of strings contains a given string
func contains(s []string, str string) bool {
	for _, v := range s {
		if v == str {
			return true
		}
	}

	return false
}
